Доделать задания из списка:

Задание 1: Создание базового класса и производных классов (30 минут)
Цель: Научиться создавать базовые и производные классы с использованием виртуальных методов.
1. Создайте базовый класс Animal с виртуальным методом speak(), который выводит на экран звук, издаваемый животным.
2. Создайте два производных класса: Dog и Cat, которые переопределяют метод speak() для вывода "Гав!" и "Мяу!" соответственно.
3. В функции main() создайте массив указателей на Animal и заполните его объектами Dog и Cat. Вызовите метод speak() для каждого объекта в массиве.

Задание 2: Использование модификаторов override и final (30 минут)
Цель: Понять, как использовать модификаторы override и final в C++.
1. Измените класс Animal, добавив виртуальный метод info(), который выводит информацию о животном.
2. В классе Dog переопределите метод info() с использованием модификатора override, чтобы он выводил "Это собака".
3. В классе Cat также переопределите метод info(), но добавьте модификатор final, чтобы запретить дальнейшее переопределение этого метода в производных классах.
4. В функции main() создайте объекты Dog и Cat, вызовите метод info() для каждого из них.

Задание 3: Полиморфизм в действии
Цель: Применить полиморфизм для работы с различными типами объектов.
1. Создайте класс Shape с виртуальным методом area(), который возвращает площадь фигуры.
2. Создайте два производных класса: Circle и Rectangle, которые переопределяют метод area() для вычисления площади круга и прямоугольника соответственно.
3. В функции main() создайте массив указателей на Shape и заполните его объектами Circle и Rectangle. Вызовите метод area() для каждого объекта и выведите результат на экран.
Создайте файл Makefile для компиляции вашего проекта.

Задание 4: Работа с абстрактными классами (1)
Цель: Научиться создавать абстрактные классы и использовать их для реализации полиморфизма.
Создайте абстрактный класс Vehicle с чисто виртуальным методом move(), который не имеет реализации.
Создайте два производных класса: Car и Bicycle, которые переопределяют метод move(). Car должен выводить "Машина едет", а Bicycle — "Велосипед едет".
В функции main() создайте массив указателей на Vehicle и заполните его объектами Car и Bicycle. Вызовите метод move() для каждого объекта в массиве.
Обратите внимание на то, что нельзя создать объект класса Vehicle, так как он является абстрактным.

Задание 5: Использование final для предотвращения переопределения (1)
Цель: Понять, как использовать модификатор final для предотвращения переопределения методов.
Создайте базовый класс Employee с виртуальным методом getSalary(), который возвращает зарплату.
Создайте производный класс Manager, который переопределяет метод getSalary() и добавляет модификатор final, чтобы запретить дальнейшее переопределение этого метода.
Создайте еще один производный класс Developer, который также переопределяет метод getSalary(), но без модификатора final.
В функции main() создайте объекты Manager и Developer, вызовите метод getSalary() для каждого из них и выведите результаты на экран.
Попробуйте создать класс SeniorDeveloper, который наследует от Developer и переопределяет метод getSalary().
Обратите внимание на то, что это возможно, в отличие от класса Manager.

Задание 6: Запрет переопределения методов (1)
Цель: Понять, как использовать модификатор final для запрета переопределения методов.
Создайте базовый класс Employee с виртуальным методом work(), который выводит "Работаю".
Создайте производный класс Manager, который переопределяет метод work() и добавляет модификатор final, чтобы запретить дальнейшее переопределение этого метода.
Создайте еще один производный класс Intern, который также наследует от Employee и переопределяет метод work(), выводя "Стажируюсь".
В функции main() создайте объекты Manager и Intern, вызовите метод work() для каждого из них.
Попробуйте создать еще один класс, который наследует от Manager, и проверьте, что компилятор выдаст ошибку.
Ожидаемый результат: Студенты должны понять, как использовать модификатор final для ограничения возможности переопределения методов и как это влияет на иерархию классов.

Задание 7: Полиморфизм с использованием коллекций (1)
Цель: Научиться использовать полиморфизм с контейнерами стандартной библиотеки C++.
Создайте базовый класс Vehicle с виртуальным методом move(), который выводит на экран, как движется транспортное средство.
Создайте два производных класса: Car и Bicycle, которые переопределяют метод move(), выводя "Машина едет" и "Велосипед едет" соответственно.
Используйте стандартный контейнер std::vector для хранения указателей на объекты Vehicle.
Заполните вектор объектами Car и Bicycle.
Напишите цикл, который проходит по вектору и вызывает метод move() для каждого элемента.
Ожидаемый результат: Студенты должны увидеть, как полиморфизм работает с контейнерами STL и как можно управлять различными типами объектов через базовый класс.

Задание 8: Использование виртуальных деструкторов (1)
Цель: Понять важность виртуальных деструкторов в иерархии классов.
Создайте базовый класс Base с виртуальным методом show() и виртуальным деструктором.
Создайте производный класс Derived, который переопределяет метод show(), выводя "Это производный класс".
В функции main() создайте указатель на Base, который указывает на объект Derived.
Удалите объект через указатель на базовый класс.
Проверьте, что деструктор Derived вызывается корректно, добавив вывод в деструкторы обоих классов.

Задание 9: Полиморфизм с использованием интерфейсов (2)
Цель: Понять, как реализовать интерфейсы с помощью чисто виртуальных методов.
Создайте интерфейс IPlayable с чисто виртуальным методом play().
Создайте два класса: Song и Video, которые реализуют интерфейс IPlayable и переопределяют метод play(), выводя "Играет песня" и "Играет видео" соответственно.
В функции main() создайте массив указателей на IPlayable и заполните его объектами Song и Video.
Вызовите метод play() для каждого объекта.

Задание 10: Реализация системы управления транспортными средствами (2)
Цель: Научиться использовать полиморфизм для работы с различными типами транспортных средств.
Создайте базовый класс Vehicle с виртуальным методом fuelEfficiency(), который возвращает эффективность топлива (например, километры на литр).
Создайте два производных класса: Car и Truck, которые переопределяют метод fuelEfficiency().
В классе Car реализуйте метод так, чтобы он возвращал значение, например, 15.0 (км/л).
В классе Truck реализуйте метод так, чтобы он возвращал значение, например, 8.0 (км/л).
В функции main() создайте массив указателей на Vehicle и заполните его объектами Car и Truck.
Напишите цикл, который проходит по массиву и выводит эффективность топлива для каждого транспортного средства.
Ожидаемый результат: Студенты должны увидеть, как полиморфизм позволяет работать с разными типами объектов через указатель на базовый класс.

Задание 11: Создание иерархии классов для сотрудников (2)
Цель: Понять, как использовать модификаторы override и final в контексте иерархии классов.
Создайте базовый класс Employee с виртуальным методом calculateSalary(), который возвращает зарплату сотрудника.
Создайте два производных класса: Manager и Developer.
В классе Manager переопределите метод calculateSalary() с использованием модификатора override, чтобы он возвращал зарплату с учетом бонусов (например, базовая зарплата + 20%).
В классе Developer также переопределите метод calculateSalary(), но добавьте модификатор final, чтобы запретить дальнейшее переопределение этого метода.
В функции main() создайте объекты Manager и Developer, вызовите метод calculateSalary() для каждого из них и выведите результаты на экран.
Ожидаемый результат: Студенты должны понять, как использовать модификаторы override и final, а также увидеть, как полиморфизм работает в контексте иерархии классов.
